/*
 * drawable.c - drawable class
 *
 * Copyright © 2008-2009 Julien Danjou <julien@danjou.info>
 * Copyright © 2010-2012 Uli Schlachter <psychon@znc.in>
 * Copyright ©      2023 Abigail Teague <ateague063@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/** Low-level API to allow Cairo to draw on clients and wiboxes.
 *
 * @author Uli Schlachter &lt;psychon@znc.in&gt;
 * @copyright 2012 Uli Schlachter
 * @coreclassmod drawable
 */

#include "drawable.h"
#include "common/object.h"
#include "globalconf.h"
#include "luaa.h"

#include <cairo-xcb.h>

/** Drawable object.
 *
 * @property image
 * @tparam image image
 * @propertydefault Autogenerated.
 */

/**
 * @signal button::press
 */

/**
 * @signal button::release
 */

/**
 * @signal mouse::enter
 */

/**
 * @signal mouse::leave
 */

/**
 * @signal mouse::move
 */

/**
 * @signal property::geometry
 */

/**
 * @signal property::height
 */

/**
 * @signal property::width
 */

/**
 * @signal property::x
 */

/**
 * @signal property::y
 */

/**
 * @signal property::surface
 */

/** Get the number of instances.
 *
 * @return The number of drawable objects alive.
 * @staticfct instances
 */

/* Set a __index metamethod for all drawable instances.
 * @tparam function cb The meta-method
 * @staticfct set_index_miss_handler
 */

/* Set a __newindex metamethod for all drawable instances.
 * @tparam function cb The meta-method
 * @staticfct set_newindex_miss_handler
 */

drawable_t *make_drawable(lua_State *L, drawable_refresh_callback *callback, void *data) {
    luaC_construct(L, 0, "Drawable");
    drawable_t *p       = lua_touserdata(L, -1);
    p->refresh_callback = callback;
    p->refresh_data     = data;
    return p;
}

static void drawable_unset_surface(drawable_t *d) {
    cairo_surface_finish(d->surface);
    cairo_surface_destroy(d->surface);
    if (d->pixmap) xcb_free_pixmap(globalconf.connection, d->pixmap);
    d->refreshed = false;
    d->surface   = NULL;
    d->pixmap    = XCB_NONE;
}

void drawable_set_geometry(lua_State *L, int didx, area_t geom) {
    drawable_t *d     = luaC_checkuclass(L, didx, "Drawable");
    area_t      old   = d->geometry;
    d->geometry       = geom;

    bool size_changed = (old.width != geom.width) || (old.height != geom.height);
    if (size_changed) drawable_unset_surface(d);
    if (size_changed && geom.width > 0 && geom.height > 0) {
        d->pixmap = xcb_generate_id(globalconf.connection);
        xcb_create_pixmap(
            globalconf.connection, globalconf.default_depth, d->pixmap, globalconf.screen->root,
            geom.width, geom.height);
        d->surface = cairo_xcb_surface_create(
            globalconf.connection, d->pixmap, globalconf.visual, geom.width, geom.height);
        luna_object_emit_signal(L, didx, ":property.surface", 0);
    }

    if (!AREA_EQUAL(old, geom)) luna_object_emit_signal(L, didx, ":property.geometry", 0);
    if (old.x != geom.x) luna_object_emit_signal(L, didx, ":property.x", 0);
    if (old.y != geom.y) luna_object_emit_signal(L, didx, ":property.y", 0);
    if (old.width != geom.width) luna_object_emit_signal(L, didx, ":property.width", 0);
    if (old.height != geom.height) luna_object_emit_signal(L, didx, ":property.height", 0);
}

static void lunaL_drawable_alloc(lua_State *L) {
    drawable_t *d       = lua_newuserdatauv(L, sizeof(drawable_t), 1);
    d->refresh_callback = NULL;
    d->refresh_data     = NULL;
    d->refreshed        = false;
    d->surface          = NULL;
    d->pixmap           = XCB_NONE;
}

static void lunaL_drawable_gc(lua_State *L, void *d) {
    drawable_unset_surface((drawable_t *)d);
}

/** Refresh a drawable's content. This has to be called whenever some drawing to
 * the drawable's surface has been done and should become visible.
 *
 * @method refresh
 * @noreturn
 */
static int lunaL_drawable_refresh(lua_State *L) {
    drawable_t *drawable = luaC_checkuclass(L, 1, "Drawable");
    drawable->refreshed  = true;
    (*drawable->refresh_callback)(drawable->refresh_data);
    return 0;
}

/** Get drawable geometry. The geometry consists of x, y, width and height.
 *
 * @treturn table A table with drawable coordinates and geometry.
 * @method geometry
 */
static int lunaL_drawable_geometry(lua_State *L) {
    drawable_t *d = luaC_checkuclass(L, 1, "Drawable");
    return luaA_pusharea(L, d->geometry);
}

lunaL_getter(drawable, surface) {
    drawable_t *drawable = luaC_checkuclass(L, 1, "Drawable");
    if (drawable->surface) /* Lua gets its own reference which it will have to destroy */
        lua_pushlightuserdata(L, cairo_surface_reference(drawable->surface));
    else lua_pushnil(L);
    return 1;
}

static luaL_Reg drawable_methods[] = {
    {"refresh",  lunaL_drawable_refresh },
    {"geometry", lunaL_drawable_geometry},
    {NULL,       NULL                   }
};

static luaC_Class drawable_class = {
    .name      = "Drawable",
    .parent    = "Object",
    .user_ctor = 0,
    .alloc     = lunaL_drawable_alloc,
    .gc        = lunaL_drawable_gc,
    .methods   = drawable_methods};

void luaC_register_drawable(lua_State *L) {
    lua_pushlightuserdata(L, &drawable_class);
    luaC_register(L, -1);
    lunaL_readonly_prop(drawable, surface);
}

/* @DOC_cobject_COMMON@ */

// vim: filetype=c:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
